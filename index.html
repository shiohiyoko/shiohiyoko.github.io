<!DOCTYPE html>
<html lang="en">
    <head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
              margin: 0px;
              overflow: hidden;
            }
          </style>
	</head>
  <body>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
		{
			"imports": {
			"three": "https://unpkg.com/three@0.148.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
			}
		}
    </script>

    <script type="module">
		import * as THREE from "three";
		import { OrbitControls } from "three/addons/controls/OrbitControls.js";
		import Stats from "three/addons/libs/stats.module.js";
		import { VRButton } from 'three/addons/webxr/VRButton.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

		let stats;

		let camera, scene, renderer, control;
		let pointLight;

		//gui
		let gui;
		const gui_obj = {
			leftWall: '#FF0000',
			centerWall: '#FFFFFF',
			rightWall: '#7CFC00',
			directional: true,
			point: false,
			spot: false,
			hemisphere: false,
		};

		// folder for lil gui
		let directional_folder, point_folder,spot_folder, hemi_folder;

		// parameter for lights
		const directional_param = {
			color: '#FFFFFF',
			intensity: 1.0
		}
		const point_param = {
			color: '#FFFFFF',
			intensity: 1.0,
			distance:100,
			decay: 2
		}
		const spot_param = {
			color: '#FFFFFF',
			intensity: 1.0
		}
		const hemisphere_param = {
			color: '#FFFFFF',
			intensity: 1.0
		}

		// ceiling light
		let ceiling_light;

		init();
		CreateTelelumenLightingSystem();
		BuildBasicModel();


		renderer.setAnimationLoop( function (time) {

			animate(time);
			renderer.render( scene, camera );
		} );

		// initialize camera, light, and position
		function init() {
			const container = document.createElement("div");
			document.body.appendChild(container);

			scene = new THREE.Scene();

			// renderer setup
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
			container.appendChild(renderer.domElement);

			// caera setup
			camera = new THREE.PerspectiveCamera(
				45,
				window.innerWidth / window.innerHeight,
				1,
				2000
			);
			camera.position.set(0, 100, -300);
			control = new OrbitControls(camera, renderer.domElement);

			// light 
			const ambient = new THREE.AmbientLight(0x404040, 0.9);
			ambient.name = "ambient";
			ambient.position.set(500,500,0);
			scene.add(ambient);

			// Grid setup
			const helper = new THREE.GridHelper(1000, 40, 0x303030, 0x303030);
			// helper.position.y = -75;
			scene.add(helper);

			// Lights
			// const light = new THREE.DirectionalLight();
			// light.position.set(0, 250, 0);
			// scene.add(light);

			// const light_helper = new THREE.DirectionalLightHelper( light, 5 );
			// scene.add(light_helper);

			// lil-gui setup
			setlilGUI();

			// show fps
			stats = new Stats();
			container.appendChild(stats.dom);

			//web xr
			document.body.appendChild( VRButton.createButton( renderer ) );
			renderer.xr.enabled = true;

			window.addEventListener("resize", onWindowResize);
		}

		// function for resizing the window
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}
		
		//function for lil-gui
		function setlilGUI(){
			gui = new GUI();
			gui.addColor( gui_obj, 'leftWall' );
			gui.addColor( gui_obj, 'centerWall' );
			gui.addColor( gui_obj, 'rightWall' );

			gui.add(gui_obj, 'directional');
			directional_folder = gui.addFolder('directional')
			directional_folder.addColor(directional_param, 'color');
			directional_folder.add(directional_param, 'intensity', 0,1,0.1);
			directional_folder.show(gui_obj.directional);
			
			gui.add(gui_obj, 'point');
			point_folder = gui.addFolder('point');
			point_folder.addColor(point_param, 'color');
			point_folder.add(point_param, 'intensity', 0,1,0.1);
			point_folder.add(point_param, 'distance', 0, 1000, 10);
			point_folder.add(point_param, 'decay', 0, 10, 1);
			point_folder.show(gui_obj.point);

			gui.add(gui_obj, 'spot');
			spot_folder = gui.addFolder('spot');
			spot_folder.addColor(spot_param, 'color');
			spot_folder.add(spot_param, 'intensity', 0,1,0.1);
			spot_folder.show(gui_obj.spot);

			gui.add(gui_obj, 'hemisphere');
			hemi_folder = gui.addFolder('hemisphere');
			hemi_folder.addColor(hemisphere_param, 'color');
			hemi_folder.add(hemisphere_param, 'intensity', 0,1,0.1);
			hemi_folder.show(gui_obj.hemisphere);

		}

		function BuildBasicModel(){

			// tabel 
			const tabel_top = new THREE.Mesh( new THREE.BoxGeometry( 100, 5, 50 ), new THREE.MeshLambertMaterial({ color: 0x808080}));
			tabel_top.castShadow = true;
			tabel_top.receiveShadow = true;
			tabel_top.position.y = 50;
			scene.add(tabel_top);

			for(let i = 0; i<4; i++){
				const tabel_leg = new THREE.Mesh( new THREE.BoxGeometry( 5, 50, 5 ), new THREE.MeshLambertMaterial({ color: 0x808080 }));
				tabel_leg.castShadow = true;
				tabel_leg.receiveShadow = true;
				tabel_leg.position.set(45*Math.cos(Math.PI/2*i)-45*Math.sin(Math.PI/2*i), 25, 20*Math.cos(Math.PI/2*i)+20*Math.sin(Math.PI/2*i));
				scene.add(tabel_leg);
			}

			// basic models
			//cone
			const cone = new THREE.Mesh( new THREE.ConeGeometry( 5, 20, 32 ), new THREE.MeshLambertMaterial( {color: 0xffff00}) );
			cone.castShadow = true;
			cone.receiveShadow = true;
			cone.position.y = 60;
			cone.position.x = -25;
			scene.add( cone );

			//cylinder
			const cylinder = new THREE.Mesh( new THREE.CylinderGeometry( 5, 5, 20, 32 ), new THREE.MeshPhongMaterial( {color: 0xffff00} ) );
			cylinder.castShadow = true;
			cylinder.receiveShadow = true;
			cylinder.position.y = 60;
			cylinder.position.x = 25;
			scene.add( cylinder );

			//sphere
			const sphere = new THREE.Mesh( new THREE.SphereGeometry( 5, 32, 32 ), new THREE.MeshPhysicalMaterial( { color: 0xffff00 } ) );
			sphere.castShadow = true;
			sphere.receiveShadow = true;
			sphere.position.y = 60;
			scene.add( sphere );
		}

		// function to create telelumen light system
		function CreateTelelumenLightingSystem(){
			// all the value are cm
			let wall_tmp = [];
			let room_size = 200;
			let frame_size = 10;
			let wall_frame_space = 50;
			let roof_thickness = 5;
			let light_size = 20;
			
			const leg1 = CreateFrame( room_size, frame_size )
			leg1.name ="leg1";
			leg1.position.set((room_size+frame_size)/2, room_size, (room_size+frame_size)/2);
			leg1.rotation.x = Math.PI/2;
			
			for(let i=0; i<4; i++){
				const tmp = leg1.clone();
				let pos = tmp.position;
				tmp.position.set(	pos.x*Math.cos(Math.PI/2*i)-pos.z*Math.sin(Math.PI/2*i), 
									pos.y, 
									pos.x*Math.sin(Math.PI/2*i)+pos.z*Math.cos(Math.PI/2*i));
				scene.add(tmp);

			}
			// top of the frame on the wall
			const wallframe_top = CreateFrame( room_size, frame_size);
			wallframe_top.name ="wallframe_top";
			wallframe_top.position.set(-(room_size)/2, room_size-frame_size/2, room_size/2+frame_size/2);
			wallframe_top.rotation.y = Math.PI/2;
			wall_tmp.push(wallframe_top);

			const wallframe_bottom = CreateFrame( room_size, frame_size );
			wallframe_bottom.name ="wallframe_bottom";
			wallframe_bottom.position.set(-(room_size)/2, room_size-frame_size/2-wall_frame_space, room_size/2+frame_size/2);
			wallframe_bottom.rotation.y = Math.PI/2;
			wall_tmp.push(wallframe_bottom);

			for(let i=0; i<4; i++)
				for(let j=0; j<wall_tmp.length; j++){
					const tmp = wall_tmp[j].clone();
					let pos = tmp.position;
					tmp.position.set(pos.x*Math.cos(Math.PI/2*i)-pos.z*Math.sin(Math.PI/2*i), 
									 pos.y, 
									 pos.x*Math.sin(Math.PI/2*i)+pos.z*Math.cos(Math.PI/2*i));
					if(i%2 == 0)
						tmp.rotation.y = Math.PI/2*(i+1);
					else
						tmp.rotation.y = Math.PI/2*(i-1);
					scene.add(tmp);
				}
			
			// top wall mesh
			for(let i=0; i<4; i++) {
				const wall_mesh = new THREE.MeshPhysicalMaterial({color:0x7CFC00});
				// wall_mesh.color.setHex(0x7CFC00);
				const top_wall = new THREE.Mesh( new THREE.BoxGeometry(room_size, wall_frame_space, 3), wall_mesh );
				top_wall.castShadow = true;
				top_wall.receiveShadow = true;
				top_wall.position.set((room_size/2+frame_size/2)*Math.cos(Math.PI/2*i), 
										room_size-frame_size*2-roof_thickness, 
										(room_size/2+frame_size/2)*Math.sin(Math.PI/2*i));
				top_wall.rotation.y = Math.PI/2*(i+1);
				scene.add(top_wall);
			}

			// wall mesh
			const wall_mesh = [new THREE.MeshPhysicalMaterial({color: gui_obj.leftWall}), new THREE.MeshPhysicalMaterial({color: gui_obj.centerWall}), new THREE.MeshPhysicalMaterial({color: gui_obj.rightWall})]
			const wall_name = ["leftWall", "centerWall", "rightWall"];
			for(let i=0; i<3; i++) {
				const wall = new THREE.Mesh( new THREE.BoxGeometry(room_size, room_size-wall_frame_space-frame_size, 3), wall_mesh[i] );
				wall.castShadow	= true;
				wall.receiveShadow = true;
				wall.name = wall_name[i];
				wall.position.set((room_size/2+frame_size/2)*Math.cos(Math.PI/2*i), 
										room_size/2-frame_size*2-roof_thickness*2, 
										(room_size/2+frame_size/2)*Math.sin(Math.PI/2*i));

				wall.rotation.y = Math.PI/2*(i+1);
				scene.add(wall);
			}

			// roof mesh
			const roof = new THREE.Mesh( new THREE.BoxGeometry( room_size+frame_size*2, roof_thickness, room_size+frame_size*2 ), new THREE.MeshPhysicalMaterial({ flatShading: false }));
			roof.name ="roof";
			roof.castShadow = true;
			roof.receiveShadow = true;
			roof.position.set(0, room_size+roof_thickness/2, 0);
			scene.add(roof);

			// floor mesh
			const floor = new THREE.Mesh( new THREE.BoxGeometry( room_size+frame_size*2, 1, room_size+frame_size*2 ), new THREE.MeshPhysicalMaterial({ color: 0xFFFFFF }));
			floor.name ="floor";
			floor.castShadow = true;
			floor.receiveShadow = true;
			floor.position.set(0, 0, 0);
			scene.add(floor);

			// roof frame mesh
			const roof_frame1 = CreateFrame(room_size, frame_size);
			roof_frame1.name ="roof";
			roof_frame1.castShadow = true;
			roof_frame1.receiveShadow = true;
			roof_frame1.position.set(room_size/2, room_size, room_size/2-room_size/3);
			roof_frame1.rotation.y = -Math.PI/2;
			scene.add(roof_frame1);
			
			const roof_frame2 = CreateFrame(room_size, frame_size);
			roof_frame2.name ="roof";
			roof_frame2.castShadow = true;
			roof_frame2.receiveShadow = true;
			roof_frame2.position.set(room_size/2, room_size, room_size/2-room_size*2/3);
			roof_frame2.rotation.y = -Math.PI/2;
			scene.add(roof_frame2);
			
			const roof_frame3 = CreateFrame( room_size/3-frame_size/2 , frame_size);
			roof_frame3.name ="roof";
			roof_frame3.castShadow = true;
			roof_frame3.receiveShadow = true;
			roof_frame3.position.set(0, room_size, room_size/6+frame_size/2);
			scene.add(roof_frame3);

			const roof_frame4 = CreateFrame( room_size/3-frame_size/2, frame_size );
			roof_frame4.name ="roof";
			roof_frame4.castShadow = true;
			roof_frame4.receiveShadow = true;
			roof_frame4.position.set(0, room_size, -room_size/6-frame_size/2);
			roof_frame4.rotation.y = Math.PI;
			scene.add(roof_frame4);
			
			const roof_frame5 = CreateFrame( room_size/3-frame_size, frame_size);
			roof_frame5.name ="roof";
			roof_frame5.castShadow = true;
			roof_frame5.receiveShadow = true;
			roof_frame5.position.set(room_size/2-room_size/3, room_size, -room_size/6+frame_size/2);
			scene.add(roof_frame5);
			
			const roof_frame6 = roof_frame5.clone();
			roof_frame6.position.x = -room_size/2+room_size/3;
			scene.add(roof_frame6);

			// roof light mesh
			const roof_light = new THREE.Mesh( new THREE.CylinderGeometry( light_size/2, light_size, 10, 4 ), new THREE.MeshPhongMaterial( {color: 0xffff00} ) );
			roof_light.position.y = room_size-5;
			roof_light.rotation.y = Math.PI/4;
			scene.add(roof_light);

			// light system

			// Lights
			const direction = new THREE.DirectionalLight({intensity: gui_obj.directional, color:directional_param.color});
			direction.name = "direction";
			direction.needsUpdate = true;
			direction.position.set(0,180, 0);
			direction.castShadow = true;
			direction.shadow.mapSize.width = 512; // default
			direction.shadow.mapSize.height = 512; // default
			direction.shadow.camera.near = 0.5; // default
			direction.shadow.camera.far = 500; // default

			scene.add(direction);

			const directional_helper = new THREE.DirectionalLightHelper( direction, 5 );
			scene.add(directional_helper);

			// point light
			const point = new THREE.PointLight( 0xff0000, point_param.intensity, point_param.distance, point_param.decay );
			point.name = "point";
			point.position.set( 0, 180, 0);
			point.castShadow = true;
			scene.add( point );

			const point_helper = new THREE.PointLightHelper( point, 5);
			scene.add( point_helper );

			const spot = new THREE.SpotLight({intensity: gui_obj.spot});
			spot.name = "spot";
			spot.castShadow = true;
			spot.position.set(0,180,0);
			scene.add(spot);

			const spot_helper = new THREE.SpotLightHelper( spot, 5 );
			scene.add(spot_helper);

			const hemisphere = new THREE.HemisphereLight({intensity: gui_obj.hemisphere});
			hemisphere.name = "hemisphere";
			hemisphere.position.set(0,180,0);
			scene.add(hemisphere);

			const hemi_helper = new THREE.HemisphereLightHelper( hemisphere, 5 );
			// helper.hide();
			scene.add(hemi_helper);
		}

		// function to create basic frame fro telelumen lighting system
		function CreateFrame(f_length, f_size){

			const shape =  new THREE.Shape();
			let rail = f_size/10;
			let side =[ [0,				 0], 
						[f_size/5,  	 0],
						[f_size/5,  	 rail],
						[f_size/5+rail,  rail],
						[f_size/5+rail,  0],
						[f_size/5*3+rail,0],
						[f_size/5*3+rail,rail],
						[f_size/5*4, 	 rail],
						[f_size/5*4,	 0],
						[f_size,		 0]]

			for(let i = 0; i < side.length; i++){
				side[i][0] -= f_size/2; 
				side[i][1] -= f_size/2; 
				
			}

			shape.moveTo( side[0][0], side[0][1]);
			for(let i=0; i<4; i++){
				for(let j=0; j<side.length; j++){
					let idx = Math.abs(j - (side.length-1)*(i%2));

					shape.lineTo( side[idx][0]*Math.cos(Math.PI/2*i)-side[idx][1]*Math.sin(Math.PI/2*i), 
							-side[idx][0]*Math.sin(Math.PI/2*i)+side[idx][1]*Math.cos(Math.PI/2*i) );			  
				}
			}

			const extrudeSettings = {
				steps: 2,
				depth: f_length,
				bevelEnabled: true,
				bevelThickness: 0,
				bevelSize: 0,
				bevelOffset: 0,
				bevelSegments: 1
			};

			const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
			const material = new THREE.MeshLambertMaterial({ flatShading: false , color: 0x808080});
			const mesh = new THREE.Mesh( geometry, material ) ;
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			// mesh.scale.set(scale, scale, scale);
			// mesh.scale.set(f_scale, f_scale, 1);
			return mesh ;
		}
		
		// animation loop
		function animate(time) {
			scene.getObjectByName("leftWall").material.color.set(gui_obj.leftWall);
			scene.getObjectByName("rightWall").material.color.set(gui_obj.rightWall);
			scene.getObjectByName("centerWall").material.color.set(gui_obj.centerWall);
			
			// scene.getObjectByName("direction").intensity = gui_obj.directional;
			// scene.getObjectByName("point").intensity = gui_obj.point;
			// scene.getObjectByName("spot").intensity = gui_obj.spot;
			// scene.getObjectByName("hemisphere").intensity = gui_obj.hemisphere;

			if(gui_obj.directional){
				directional_folder.show(true);
				scene.getObjectByName("direction").intensity = directional_param.intensity;
				scene.getObjectByName("direction").color.set(directional_param.color);
			}
			else{
				directional_folder.hide();
				scene.getObjectByName("direction").intensity = 0;
			}

			if(gui_obj.point){
				point_folder.show(true);
				scene.getObjectByName("point").intensity = point_param.intensity;
				scene.getObjectByName("point").color.set(point_param.color);
				scene.getObjectByName("point").distance = point_param.distance;
				scene.getObjectByName("point").decay = point_param.decay;
			}
			else{
				point_folder.hide();
				scene.getObjectByName("point").intensity = 0;
			}
			
			if(gui_obj.spot){
				spot_folder.show();
				scene.getObjectByName("spot").intensity = spot_param.intensity;
				scene.getObjectByName("spot").color.set(spot_param.color);
			}
			else{
				spot_folder.hide();
				scene.getObjectByName("spot").intensity = 0;
			}

			if(gui_obj.hemisphere){
				hemi_folder.show();
				scene.getObjectByName("hemisphere").intensity = hemisphere_param.intensity;
				scene.getObjectByName("hemisphere").color.set(hemisphere_param.color)
			}
			else{
				hemi_folder.hide();
				scene.getObjectByName("hemisphere").intensity = 0;
			}
			stats.update();
			control.update();
		}

    </script>
  </body>
</html>
