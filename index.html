
<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - buffergeometry - particles</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>

    <div id="container"></div>

    <script id="histvertexShader" type="x-shader/x-vertex">
		uniform float time;
		varying vec2 vUv;

		void main()
		{
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4 (position, 1.0);
		}
    </script>

    <script id="histfragmentShader" type="x-shader/x-fragment">
      	uniform float time;
		varying vec2 vUv;
		uniform sampler2D tex;

		float getcolor(float thres, float uvy){
			if(thres < uvy)
				return 0.0;
			else
				return 1.0;
		}

		void main()
		{
			vec3 threshold = texture2D(tex, vUv).rgb;
			vec4 color = vec4(1.0,1.0,1.0,1.0);

			if(threshold.x < vUv.x)
				color.x = 0.0;
			if(threshold.y < vUv.x)
				color.y = 0.0;
			if(threshold.z < vUv.x)
				color.z = 0.0;
			
			if(threshold.x < vUv.x && threshold.y < vUv.x && threshold.z < vUv.x)
				discard;

			gl_FragColor = color;
		
		}
    </script>

	// used for point clouds
	<script type="x-shader/x-vertex" id="RGBVertexShader">
		uniform sampler2D tex;
		varying vec3 color;

		void main() {
			color = texture2D ( tex, position.xy ).rgb;
			gl_PointSize = 1.0;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(color, 1.0);
		}
	</script>

	<script type="x-shader/x-fragment" id="RGBFragmentShader">
		varying vec3 color;

		void main() {
			gl_FragColor.rgb = color;
			gl_FragColor.a = 1.0;
		}
	</script>

	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
	  {
		"imports": {
		  "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
		  "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
		}
	  }
	</script>

  <script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import Stats from 'three/addons/libs/stats.module.js';
	import { histogram } from './histogram.js';

	let container, stats;

	let camera, root, scene, renderer, controls;

	var canvas = document.createElement( 'canvas' );

	// settings for camera
	var video, videoTexture, plan;

	let hist, hist_texture;
	
	let points, histmap, hist_uniforms={
		tex: { value: hist_texture },
	};

	var gl = canvas.getContext("webgl");
	gl.getExtension('OES_texture_float');
	gl.getExtension('OES_texture_float_linear');
	
	init();
	createGraph();
	animate();

	function init() {
		container = document.getElementById('container');

		camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .1, 50);
		camera.position.z = 1;
		
		root = new THREE.Scene();
		scene = new THREE.Scene();
		root.add(scene);
		// scene.position.x  =10;
		scene.background = new THREE.Color(0xcccccc);

		console.log("back ground",scene.background.r);

	
		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);

		const loader = new THREE.TextureLoader();
		
		hist = new histogram();


		container.appendChild(renderer.domElement);

		controls = new OrbitControls(camera, renderer.domElement);

		stats = new Stats();
		container.appendChild(stats.dom);

		window.addEventListener('resize', onWindowResize);


		// init for camera 

		if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
			const constraints = {
				video: { width: 1920, height: 1080, facingMode: "user" },
			};
		navigator.mediaDevices
			.getUserMedia(constraints)
			.then(function (stream) {
				video = document.createElement("video");
				video.srcObject = stream;
				video.play();

				video.onloadeddata = function () {
					videoTexture = new THREE.VideoTexture(video);
					videoTexture.minFilter = THREE.LinearFilter;
					videoTexture.magFilter = THREE.LinearFilter;
					videoTexture.generateMipmaps = false;
					videoTexture.format = THREE.RGBAFormat;
					// videoTexture.encoding = THREE.LinearEncoding;

					// var geometry = new THREE.PlaneGeometry(
					// 	1,
					// 	video.videoHeight / video.videoWidth
					// );
					// var material = new THREE.MeshBasicMaterial({
					// 	map: videoTexture,
					// 	side: THREE.DoubleSide,
					// });
					// plan = new THREE.Mesh(geometry, material);
					// plan.receiveShadow = false;
					// plan.castShadow = false;
					scene.background = videoTexture;
					video.play();

					
					// histogram
					hist_texture = hist.get_hist(videoTexture.image);

					var histogramMaterial = new THREE.ShaderMaterial({
						vertexShader: document.getElementById('histvertexShader').textContent,
						fragmentShader: document.getElementById('histfragmentShader').textContent,
						uniforms: hist_uniforms
					});
					histmap = new THREE.Mesh(new THREE.PlaneGeometry(1,1), histogramMaterial);
					histmap.rotation.z = Math.PI/2;
					histmap.position.set(-1,0.5,0);

					scene.add(histmap);


					// point cloud
					var colorSpaceMaterial = new THREE.ShaderMaterial({
						vertexShader: document.getElementById('RGBVertexShader').textContent,
						fragmentShader: document.getElementById('RGBFragmentShader').textContent,
						uniforms: {
							tex: { value: videoTexture },
						}
					});

					var discret = 1;
					const pcl_geometry = new THREE.BufferGeometry();
					const positions = [];
					let compteur = 0;
					for (let i = 0; i < video.videoWidth; i += discret)
						for (let j = 0; j < video.videoHeight; j += discret) {
							// positions
							const read = new Float32Array(4);
							positions.push(i/video.videoHeight, j/video.videoWidth,0);
							compteur++;
						}

					pcl_geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
					pcl_geometry.computeBoundingSphere();
					points = new THREE.Points(pcl_geometry, colorSpaceMaterial);
					scene.add(points);
				};

				window.addEventListener("resize", onWindowResize, false);
			});
		}
	
		
	}

	function createGraph(){
		const gridHelper = new THREE.GridHelper( 1, 10 );
		gridHelper.position.x = 0.5;
		gridHelper.position.z = 0.5;
		scene.add( gridHelper );

		// create wall
		const plane_geometry = new THREE.PlaneGeometry(1,1);
		const plane_material = new THREE.MeshBasicMaterial({color: 0x80808, side: THREE.DoubleSide, transparent: true, opacity: 0.5});
		const left = new THREE.Mesh(plane_geometry, plane_material);
		left.name = 'left_wall';
		left.position.set(0, 0.5, 0.5);
		left.rotation.y = Math.PI/2;
		scene.add(left);

		const front = new THREE.Mesh(plane_geometry, plane_material);
		front.name = 'front_wall';
		front.position.set(0.5, 0.5, 0);
		scene.add(front)

		const bottom = new THREE.Mesh(plane_geometry, plane_material);
		bottom.name = 'bottom_wall';
		bottom.position.set(0.5,0,0.5);
		bottom.rotation.x = Math.PI/2;
		scene.add(bottom);

		const material = new THREE.LineBasicMaterial( { color: 0x0000ff, linewidth: 10 } );

		const points = [];
		points.push( new THREE.Vector3( 0, 0, 0));
		for(let i=0;i<1; i+= 0.1){
			points.push( new THREE.Vector3( i, 0, 0));
			points.push( new THREE.Vector3( i, 0, 0.01));
			points.push( new THREE.Vector3( i, 0, -0.01));
			points.push( new THREE.Vector3( i, 0, 0));
		}

		const geometry = new THREE.BufferGeometry().setFromPoints( points );
		

		const x_axis = new THREE.Line(geometry, new THREE.LineBasicMaterial( { color: 0xFF0000, linewidth: 5  } ));
		scene.add( x_axis );

		const y_axis = new THREE.Line(geometry, new THREE.LineBasicMaterial( { color: 0x00FF00, linewidth: 5  } ));
		y_axis.rotation.z = Math.PI/2;
		scene.add( y_axis );

		const z_axis = new THREE.Line(geometry, new THREE.LineBasicMaterial( { color: 0x0000FF, linewidth: 5  } ));
		z_axis.rotation.y = -Math.PI/2;
		scene.add( z_axis );
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function animate() {
		requestAnimationFrame(animate);
		controls.update();

		render();
		stats.update();
	}

	function render() {
		hist_uniforms.tex.value = hist.get_hist(videoTexture.image);
		renderer.render(scene, camera);
	}

	</script>

</body>

</html>